* Global settings
** Initialization
*Add package archives*
#+BEGIN_SRC emacs-lisp
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
  (add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/"))

  (setq package-enable-at-startup nil)
#+END_SRC

*Compile-time packages*
#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (require 'cl-lib)
    (require 'use-package))
  (require 'diminish)
  (require 'bind-key)
  (require 'async)
#+END_SRC

*Default settings*
#+BEGIN_SRC emacs-lisp
  ;; No more backups needed with super-save!
  (setq auto-save-default nil)
  ;; Get rid of that ugly toolbar
  (tool-bar-mode -1)
  ;; No one wants to type 2 extra characters
  (fset 'yes-or-no-p 'y-or-n-p)
  ;; Enable line numbers
  (eval-after-load "linum"
    '(set-face-attribute 'linum nil :height 100))
  (global-linum-mode t)
  (setq linum-format "%6d ")
  (linum-relative-global-mode 1)
  (setq linum-relative-current-symbol "")
  (column-number-mode t)
  ;; Show trailing whitespace
  (add-hook 'prog-mode-hook
            (lambda()
              (interactive) (setq show-trailing-whitespace 1)))
  ;; Set default indentation settings
  (setq-default indent-tabs-mode nil)
  (setq-default tab-width 4)
#+END_SRC

** Aliases
#+BEGIN_SRC emacs-lisp
  ;; Align-regexp
  (defalias 'ar #'align-regexp)
  ;; List-packages
  (defalias 'lp #'list-packages)
#+END_SRC

* Package settings
** Smartparens
#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :defer t
    :init 
    ()
    :config
    (require 'smartparens-config))
#+END_SRC

** Evil Mode
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :ensure t
    :init
    (progn
      (evil-mode 1))
    :config
    ()
    :bind (:map evil-normal-state-map
           ;; Movement
           ("L" . evil-end-of-line)
           ("H" . evil-beginning-of-line)
           ;; Buffer/file management
           ("<SPC> k" . kill-buffer)
           ("<SPC> K" . kill-some-buffers)
           ("<SPC> c" . clone-indirect-buffer)
           ("<SPC> w c" . clone-indirect-buffer-other-window)
           ("<SPC> w f" . find-file-other-window)
           ;; Window management
           ("<SPC> 0" . delete-window)
           ("<SPC> 1" . delete-other-windows)
           ("<SPC> 2" . split-window-below)
           ("<SPC> 3" . split-window-right)
           ;; Universal argument remap
           ("<SPC> u" . universal-argument)
           :map universal-argument-map
           ("<SPC> u" . universal-argument-more)
           ;; Visual state equivalents
           :map evil-visual-state-map
           ("L" . evil-end-of-line)
           ("H" . evil-beginning-of-line)))
  (use-package evil-surround
    :ensure t
    :defer t
    :init
    (global-evil-surround-mode 1))
  (use-package evil-nerd-commenter
    :ensure t
    :defer t
    :init
    (evilnc-default-hotkeys))
#+END_SRC

** Helm
*** General setup
*initial helm configuration*
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :ensure t
    :init
    (progn
      (require 'helm-config)
      (setq helm-split-window-in-side-p t
            helm-move-to-line-cycle-in-source t
            helm-buffers-fuzzy-matching t
            helm-ff-file-name-history-use-recentf t
            helm-M-x-fuzzy-match t)
      (helm-mode 1))
    :config
    ()
    :bind (("M-x" . helm-M-x)
           ("M-y" . helm-show-kill-ring)
           ("C-h i" . helm-info-at-point)
           ("C-x C-f" . helm-find-files)
           ("C-x C-d" . helm-browse-project)
           ("C-x C-b" . helm-buffers-list)
           :map helm-map
           ("<tab>" . helm-execute-persistent-action)
           ("C-z" . helm-select-action)
           :map evil-normal-state-map
           ("<SPC> e" . helm-buffers-list)
           ("<SPC> d" . helm-browse-project)
           ("<SPC> f" . helm-find-files)
           ("<SPC> <SPC>" . helm-M-x)
           ("<SPC> y" . helm-show-kill-ring)))

  (use-package helm-ag
    :ensure t
    :defer t)

  (use-package helm-ls-git
    :ensure t
    :defer t)

  (use-package helm-descbinds
    :ensure t
    :defer t
    :init
    (helm-descbinds-mode))
#+END_SRC

*** Helm-Projectile
*helm-projectile configuration*
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :init
    (progn
      (setq projectile-completion-system 'helm)
      (projectile-global-mode)))

  (use-package helm-projectile
    :ensure t
    :defer t
    :init
    (progn
      (helm-projectile-on))
    :bind (:map evil-normal-state-map
           ("<SPC> p h" . helm-projectile)
           ("<SPC> p f" . helm-projectile-find-file)
           ("<SPC> p d" . helm-projectile-find-dir)
           ("<SPC> p b" . helm-projectile-switch-to-buffer)))
#+END_SRC

*** Helm-Swoop
#+BEGIN_SRC emacs-lisp
    (use-package helm-swoop
      :ensure t
      :defer t
      :init
      (progn
        (setq helm-multi-swoop-edit-save t
              helm-swoop-split-direction 'split-window-vertically
              helm-swoop-move-to-line-cycle t))
      :bind(("M-s o" . helm-swoop)
            ("M-s /" . helm-multi-swoop)
            :map helm-swoop-map
            ("C-p" . helm-previous-line)
            ("C-n" . helm-next-line)
            :map helm-multi-swoop-map
            ("C-p" . helm-previous-line)
            ("C-n" . helm-next-line)
            :map evil-normal-state-map
            ("<SPC> i" . helm-swoop)
            ("<SPC> m" . helm-multi-swoop)
            :map evil-visual-state-map
            ("<SPC> i" . helm-swoop)
            ("<SPC> m" . helm-multi-swoop)))
#+END_SRC

** Hydra
#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :ensure t
    :defer t)
#+END_SRC

*Text-scaling hydra*
#+BEGIN_SRC emacs-lisp
  (defhydra hydra-zoom (global-map "<f2>")
    "zoom"
    ("g" text-scale-increase "in")
    ("l" text-scale-decrease "out"))
#+END_SRC

** Magit
*General setup*
#+BEGIN_SRC emacs-lisp
    (use-package magit
      :ensure t
      :init
      (progn
        (setq global-magit-file-mode t
              magit-repository-directories-depth 1))
      :config
      ;; Populate magit with projectile's git repository cache
      (eval-after-load "projectile"
        '(progn (setq magit-repository-directories
                      (mapcar (lambda (dir)
                                (substring dir 0 -1))
                              (remove-if-not (lambda (project)
                                               (file-directory-p (concat project "/.git/")))
                                             (projectile-relevant-known-projects))))))
      :bind (("C-x g" . magit-status)
             :map evil-normal-state-map
             ("<SPC> g" . magit-status)))
#+END_SRC

** Yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :init
    (progn
      (add-to-list 'load-path
                "~/.emacs.d/plugins/yasnippet")
      (yas-global-mode 1)))
#+END_SRC

** Flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :diminish flycheck-mode
    :init
    (progn
      (add-hook 'after-init-hook #'global-flycheck-mode)))
#+END_SRC

** Pos-tip
#+BEGIN_SRC emacs-lisp
  (use-package pos-tip)
#+END_SRC

** Company auto-completion
*** General setup
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :init
    (progn
      (setq company-idle-delay .3))
    :config
    (setq company-backends (delete 'company-semantic company-backends))
    :bind (("M-/" . company-complete)
           :map evil-insert-state-map
           ("C-p" . company-select-previous)
           ("C-n" . company-select-next)))
  (add-hook 'after-init-hook 'global-company-mode)
#+END_SRC

*Company-quickhelp pop-ups*
#+BEGIN_SRC emacs-lisp
  (use-package company-quickhelp
    :defer t
    :ensure t
    :init
    (progn
      (setq company-quickhelp-delay .3)
      (company-quickhelp-mode 1)))
#+END_SRC

*Yasnippet integration in every backend*
#+BEGIN_SRC emacs-lisp
  ;; Add yasnippet support for all company backends
  (defvar company-mode/enable-yas t
  "Enable yasnippet for all backends.")
  (defun company-mode/backend-with-yas (backend)
  (if (or (not company-mode/enable-yas) (and (listp backend) (member 'company-yasnippet backend)))
      backend
      (append (if (consp backend) backend (list backend))
              '(:with company-yasnippet))))
  (setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))
#+END_SRC

*** Python completion
#+BEGIN_SRC emacs-lisp
  (setq python-shell-interpreter "/usr/bin/ipython3")
  (use-package jedi-core
    :ensure t
    :init
    (progn
      (setq jedi:complete-on-dot t
            jedi:get-in-function-call-delay 500)
      (add-hook 'python-mode-hook 'jedi:setup)))

  (use-package elpy
    :ensure t
    :init
    (progn
      (setq elpy-rpc-backend "jedi")
      ;; Elpy uses company for completion
      ;; so we don't have to specify a backend
      (elpy-enable)))
#+END_SRC

*** Ruby completion
#+BEGIN_SRC emacs-lisp
  (setq ruby-indent-level 2)
  (use-package ruby-mode
    :mode ("\\.rb\\'"
           "\\.ru\\'"
           "\\.rake\\'"
           "\\.gemspec\\'"
           "\\Rakefile\\'"
           "\\Gemfile\\'")
    :interpreter "ruby")

  (use-package inf-ruby
    :ensure t
    :defer t
    :init
    (progn
      (add-hook 'compilation-filter-hook 'inf-ruby-auto-enter)))

  (use-package rubocop
    :ensure t
    :defer t
    :init
    (add-hook 'ruby-mode-hook #'rubocop-mode))
#+END_SRC

*** Company-web-mode
*General setup*
#+BEGIN_SRC emacs-lisp
  (defun my/web-mode-hook ()
    (add-to-list 'company-backends '(company-tern company-web-html)))
  (use-package company-web
    :ensure t
    :defer t
    :init
    (progn
      (add-hook 'web-mode-hook 'my/web-mode-hook))
    :config
    (;; Enable JavaScript completion between <script>...</script> tags
     (defadvice company-tern (before web-mode-set-up-ac-sources activate)
       "Set `tern-mode' based on current language before running company-tern."
       (message "advice")
       (if (equal major-mode 'web-mode)
           (let ((web-mode-cur-language
                  (web-mode-language-at-pos)))
             (if (or (string= web-mode-cur-language "javascript")
                     (string= web-mode-cur-language "jsx")
                     )
                 (unless tern-mode (tern-mode))
               (if tern-mode (tern-mode -1))))))))
#+END_SRC

*Emmet*
#+BEGIN_SRC emacs-lisp
  (use-package emmet-mode
    :ensure t
    :init
    (progn
      (add-hook 'html-mode-hook 'emmet-mode)
      (add-hook 'css-mode-hook 'emmet-mode)
      (add-hook 'scss-mode-hook 'emmet-mode)))
#+END_SRC

*** (S)CSS completion
#+BEGIN_SRC emacs-lisp
  (defun my/css-mode-hook ()
    (add-to-list 'company-backends 'company-css)
    (setq css-indent-offset 2))
  (add-hook 'css-mode-hook 'my/css-mode-hook)
  (use-package scss-mode
    :ensure t
    :mode ("\\.scss\\'" . scss-mode)
    :init
    (progn
      (setq scss-compile-at-save nil)
      (add-hook 'scss-mode-hook 'my/css-mode-hook)))
#+END_SRC

*** ES/JS completion
#+BEGIN_SRC emacs-lisp
  (defun my/js-mode-hook ()
    (add-to-list 'company-backends 'company-tern))
  (use-package company-tern
    :ensure t
    :defer t
    :init
    (progn
      (add-hook 'js-mode-hook 'my/js-mode-hook)))
#+END_SRC

*** C/C++ completion
*General emacs settings*
#+BEGIN_SRC emacs-lisp
  (setq c-default-style "linux")
  (setq c-basic-offset 8)
#+END_SRC

*Function args*
#+BEGIN_SRC emacs-lisp
  (use-package function-args
    :ensure t
    :mode ("\\.h\\'" . c++-mode)
    :init
    (progn
      (set-default 'semantic-case-fold t)
      (fa-config-default)))
#+END_SRC

*Company-c-headers*
#+BEGIN_SRC emacs-lisp
  (use-package company-c-headers
    :ensure t
    :defer t
    :init
    (progn
      (add-hook 'c-mode-hook (lambda ()
                               (add-to-list 'company-backends 'company-c-headers)))
      (add-hook 'c++-mode-hook (lambda ()
                                 (add-to-list 'company-backends 'company-c-headers))))
    :config
    (add-to-list 'company-c-headers-path-system "/usr/include/c++/6.1.1"))
#+END_SRC

*Helm-gtags*
#+BEGIN_SRC emacs-lisp
  (use-package helm-gtags
    :ensure t
    :defer t
    :init
    (progn
      (setq helm-gtags-ignore-case t
            helm-gtags-auto-update t
            helm-gtags-use-input-at-cursor t
            helm-gtags-pulse-at-cursor t
            helm-gtags-prefix-key "\C-cg"
            helm-gtags-suggested-key-mapping t)
      (add-hook 'dired-mode-hook 'helm-gtags-mode)
      (add-hook 'eshell-mode-hook 'helm-gtags-mode)
      (add-hook 'c-mode-hook 'helm-gtags-mode)
      (add-hook 'c++-mode-hook 'helm-gtags-mode)
      (add-hook 'asm-mode-hook 'helm-gtags-mode))
    :bind (:map helm-gtags-mode-map
           ("C-c g a" . helm-gtags-tags-in-this-function)
           ("C-j" . helm-gtags-select)
           ("M-." . helm-gtags-dwim)
           ("M-," . helm-gtags-pop-stack)
           ("C-c <" . helm-gtags-previous-history)
           ("C-c >" . helm-gtags-next-history)))
#+END_SRC

** Org-mode
#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure t
    :pin org
    :mode (("\\.org$" . org-mode))
    :init
    (progn
      (setq org-log-done t
            org-src-fontify-natively t))
    :bind (("\C-cl" . org-store-link)
           ("\C-ca" . org-agenda)
           ("\C-cc" . org-capture)
           ("\C-cb" . org-iswitchb)
;           :map evil-normal-state-map
;           ("t" . org-todo)
;           ("T" . org-insert-todo-heading)
;           ("<SPC> a" . org-agenda)
;           ("<SPC> t" . org-show-todo-tree)
;           ("<SPC> c" . org-archive-subtree)
;           ("<SPC> l" . org-store-link)
))
#+END_SRC

** Avy/Ace-window
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :init
    (progn
      (avy-setup-default)
      (setq avy-keys (number-sequence ?a ?z)
            avy-all-windows 'all-frames
            avy-case-fold-search nil))
    :bind (("M-s c" . avy-goto-char)
           ("M-s s" . avy-goto-char-2)
           ("M-s l" . avy-goto-line)
           ("M-s e" . avy-goto-word-0)
           ("M-s w" . avy-goto-word-1)
           :map evil-normal-state-map
           ("s" . avy-goto-char-2)
           ("<SPC> l" . avy-goto-line)
           :map evil-motion-state-map
           ("s" . avy-goto-char-2)))

  (use-package ace-window
    :ensure t
    :bind (("M-n" . ace-window)
           :map evil-normal-state-map
           ("<SPC> n" . ace-window)
           :map evil-visual-state-map
           ("<SPC> n" . ace-window)))
#+END_SRC   

** Super-save
#+BEGIN_SRC emacs-lisp
  (use-package super-save
    :ensure t
    :diminish super-save-mode
    :init
    (setq super-save-auto-save-when-idle t)
    :config
    (super-save-mode +1))
#+END_SRC

** Smart-mode-line
#+BEGIN_SRC emacs-lisp
  (use-package smart-mode-line
    :ensure t
    :init
    (progn
      (add-hook 'after-init-hook 'sml/setup)))
#+END_SRC

** Theme
#+BEGIN_SRC emacs-lisp
  (setq custom-safe-themes t)
  (setq x-underline-at-descent-line t)
  (use-package solarized-theme
    :ensure t
    :init
    (progn
      (setq solarized-distinct-fringe-background nil
            solarized-scale-org-headlines nil
            solarized-use-variable-pitch nil
            solarized-high-contrast-modeline t)
      (load-theme 'solarized-light t)))
#+END_SRC
